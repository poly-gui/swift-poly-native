// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import Foundation
import NanoPack

protocol NativeLayerServiceDelegate {
  func createWindow(
    _ title: String, _ description: String, _ width: Int32, _ height: Int32, _ tag: String)
  func createWidget(_ widget: Widget, _ windowTag: String)
  func updateWidget(_ tag: UInt32, _ widget: Widget, _ args: NanoPackMessage?)
  func updateWidgets(_ tag: [UInt32], _ widgets: [Widget], _ args: NanoPackMessage?)
}

class NativeLayerServiceServer: NPRPCServer {
  private let delegate: NativeLayerServiceDelegate

  init(channel: NPRPCServerChannel, delegate: NativeLayerServiceDelegate) {
    self.delegate = delegate
    super.init(channel: channel)
    registerCalls()
  }

  private func registerCalls() {
    on("create_window") { data, offset, msgID in
      var ptr = offset
      let titleSize = data.readSize(at: ptr)
      ptr += 4
      guard let title = data.read(at: ptr, withLength: titleSize) else {
        return nil
      }
      ptr += titleSize
      let descriptionSize = data.readSize(at: ptr)
      ptr += 4
      guard let description = data.read(at: ptr, withLength: descriptionSize) else {
        return nil
      }
      ptr += descriptionSize
      let width: Int32 = data.read(at: ptr)
      ptr += 4
      let height: Int32 = data.read(at: ptr)
      ptr += 4
      let tagSize = data.readSize(at: ptr)
      ptr += 4
      guard let tag = data.read(at: ptr, withLength: tagSize) else {
        return nil
      }
      ptr += tagSize

      self.delegate.createWindow(title, description, width, height, tag)
      var data = Data(capacity: 6)
      data.append(int: NPRPCMessageType.response.rawValue)
      data.append(int: msgID)
      data.append(int: UInt8(0))

      return data
    }
    on("create_widget") { data, offset, msgID in
      var ptr = offset
      var widgetByteSize = 0
      guard let widget = Widget.from(data: data[ptr...], bytesRead: &widgetByteSize) else {
        return nil
      }
      ptr += widgetByteSize
      let windowTagSize = data.readSize(at: ptr)
      ptr += 4
      guard let windowTag = data.read(at: ptr, withLength: windowTagSize) else {
        return nil
      }
      ptr += windowTagSize

      self.delegate.createWidget(widget, windowTag)
      var data = Data(capacity: 6)
      data.append(int: NPRPCMessageType.response.rawValue)
      data.append(int: msgID)
      data.append(int: UInt8(0))

      return data
    }
    on("update_widget") { data, offset, msgID in
      var ptr = offset
      let tag: UInt32 = data.read(at: ptr)
      ptr += 4
      var widgetByteSize = 0
      guard let widget = Widget.from(data: data[ptr...], bytesRead: &widgetByteSize) else {
        return nil
      }
      ptr += widgetByteSize
      var args: NanoPackMessage?
      if data[ptr] != 0 {
        ptr += 1
        var argsByteSize = 0
        guard let args_ = makeNanoPackMessage(from: data[ptr...], bytesRead: &argsByteSize) else {
          return nil
        }
        args = args_
        ptr += argsByteSize
      } else {
        ptr += 1
        args = nil
      }

      self.delegate.updateWidget(tag, widget, args)
      var data = Data(capacity: 6)
      data.append(int: NPRPCMessageType.response.rawValue)
      data.append(int: msgID)
      data.append(int: UInt8(0))

      return data
    }
    on("update_widgets") { data, offset, msgID in
      var ptr = offset
      let tagItemCount = data.readSize(at: ptr)
      ptr += 4
      let tagByteSize = tagItemCount * 4
      let tag = data[ptr..<ptr + tagByteSize].withUnsafeBytes {
        [UInt32]($0.bindMemory(to: UInt32.self).lazy.map { $0.littleEndian })
      }
      ptr += tagByteSize
      let widgetsItemCount = data.readSize(at: ptr)
      ptr += 4
      var widgets: [Widget] = []
      widgets.reserveCapacity(widgetsItemCount)
      for _ in 0..<widgetsItemCount {
        var iItemByteSize = 0
        guard let iItem = Widget.from(data: data[ptr...], bytesRead: &iItemByteSize) else {
          return nil
        }
        ptr += iItemByteSize
        widgets.append(iItem)
      }
      var args: NanoPackMessage?
      if data[ptr] != 0 {
        ptr += 1
        var argsByteSize = 0
        guard let args_ = makeNanoPackMessage(from: data[ptr...], bytesRead: &argsByteSize) else {
          return nil
        }
        args = args_
        ptr += argsByteSize
      } else {
        ptr += 1
        args = nil
      }

      self.delegate.updateWidgets(tag, widgets, args)
      var data = Data(capacity: 6)
      data.append(int: NPRPCMessageType.response.rawValue)
      data.append(int: msgID)
      data.append(int: UInt8(0))

      return data
    }
  }
}

class NativeLayerServiceClient: NPRPCClient {
  override init(channel: NPRPCClientChannel) {
    super.init(channel: channel)
  }

  func createWindow(
    _ title: String, _ description: String, _ width: Int32, _ height: Int32, _ tag: String,
    completionHandler: @escaping (Result<Void, NPRPCError>) -> Void
  ) {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 13)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(13))
    data.append(string: "create_window")
    data.append(size: title.lengthOfBytes(using: .utf8))
    data.append(string: title)
    data.append(size: description.lengthOfBytes(using: .utf8))
    data.append(string: description)
    data.append(int: width)
    data.append(int: height)
    data.append(size: tag.lengthOfBytes(using: .utf8))
    data.append(string: tag)

    sendRequestData(msgID, data) { data, offset in
      var ptr = offset
      let errFlag: UInt8 = data.read(at: ptr)
      ptr += 1
      guard errFlag == 0 else {
        return
      }
      completionHandler(.success(()))
    }
  }

  @available(macOS 10.15, iOS 13, *)
  func createWindow(
    _ title: String, _ description: String, _ width: Int32, _ height: Int32, _ tag: String
  ) async -> Result<Void, NPRPCError> {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 13)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(13))
    data.append(string: "create_window")
    data.append(size: title.lengthOfBytes(using: .utf8))
    data.append(string: title)
    data.append(size: description.lengthOfBytes(using: .utf8))
    data.append(string: description)
    data.append(int: width)
    data.append(int: height)
    data.append(size: tag.lengthOfBytes(using: .utf8))
    data.append(string: tag)

    return await withCheckedContinuation { continuation in
      sendRequestData(msgID, data) { data, offset in
        var ptr = offset
        let errFlag: UInt8 = data.read(at: ptr)
        ptr += 1
        guard errFlag == 0 else {
          continuation.resume(returning: .failure(.malformedResponse))
          return
        }
        continuation.resume(returning: .success(()))
      }
    }
  }

  func createWidget(
    _ widget: Widget, _ windowTag: String,
    completionHandler: @escaping (Result<Void, NPRPCError>) -> Void
  ) {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 13)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(13))
    data.append(string: "create_widget")
    let widgetByteSize = widget.write(to: &data, offset: data.count)
    data.append(size: windowTag.lengthOfBytes(using: .utf8))
    data.append(string: windowTag)

    sendRequestData(msgID, data) { data, offset in
      var ptr = offset
      let errFlag: UInt8 = data.read(at: ptr)
      ptr += 1
      guard errFlag == 0 else {
        return
      }
      completionHandler(.success(()))
    }
  }

  @available(macOS 10.15, iOS 13, *)
  func createWidget(_ widget: Widget, _ windowTag: String) async -> Result<Void, NPRPCError> {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 13)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(13))
    data.append(string: "create_widget")
    let widgetByteSize = widget.write(to: &data, offset: data.count)
    data.append(size: windowTag.lengthOfBytes(using: .utf8))
    data.append(string: windowTag)

    return await withCheckedContinuation { continuation in
      sendRequestData(msgID, data) { data, offset in
        var ptr = offset
        let errFlag: UInt8 = data.read(at: ptr)
        ptr += 1
        guard errFlag == 0 else {
          continuation.resume(returning: .failure(.malformedResponse))
          return
        }
        continuation.resume(returning: .success(()))
      }
    }
  }

  func updateWidget(
    _ tag: UInt32, _ widget: Widget, _ args: NanoPackMessage?,
    completionHandler: @escaping (Result<Void, NPRPCError>) -> Void
  ) {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 13)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(13))
    data.append(string: "update_widget")
    data.append(int: tag)
    let widgetByteSize = widget.write(to: &data, offset: data.count)
    if let args {
      data.append(int: UInt8(1))
      let argsByteSize = args.write(to: &data, offset: data.count)
    } else {
      data.append(int: UInt8(0))
    }

    sendRequestData(msgID, data) { data, offset in
      var ptr = offset
      let errFlag: UInt8 = data.read(at: ptr)
      ptr += 1
      guard errFlag == 0 else {
        return
      }
      completionHandler(.success(()))
    }
  }

  @available(macOS 10.15, iOS 13, *)
  func updateWidget(_ tag: UInt32, _ widget: Widget, _ args: NanoPackMessage?) async -> Result<
    Void, NPRPCError
  > {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 13)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(13))
    data.append(string: "update_widget")
    data.append(int: tag)
    let widgetByteSize = widget.write(to: &data, offset: data.count)
    if let args {
      data.append(int: UInt8(1))
      let argsByteSize = args.write(to: &data, offset: data.count)
    } else {
      data.append(int: UInt8(0))
    }

    return await withCheckedContinuation { continuation in
      sendRequestData(msgID, data) { data, offset in
        var ptr = offset
        let errFlag: UInt8 = data.read(at: ptr)
        ptr += 1
        guard errFlag == 0 else {
          continuation.resume(returning: .failure(.malformedResponse))
          return
        }
        continuation.resume(returning: .success(()))
      }
    }
  }

  func updateWidgets(
    _ tag: [UInt32], _ widgets: [Widget], _ args: NanoPackMessage?,
    completionHandler: @escaping (Result<Void, NPRPCError>) -> Void
  ) {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 14)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(14))
    data.append(string: "update_widgets")
    data.append(size: tag.count)
    for i in tag {
      data.append(int: i)
    }
    data.append(size: widgets.count)
    var widgetsByteSize: Size = 4
    for i in widgets {
      let iByteSize = i.write(to: &data, offset: data.count)
      widgetsByteSize += iByteSize
    }
    if let args {
      data.append(int: UInt8(1))
      let argsByteSize = args.write(to: &data, offset: data.count)
    } else {
      data.append(int: UInt8(0))
    }

    sendRequestData(msgID, data) { data, offset in
      var ptr = offset
      let errFlag: UInt8 = data.read(at: ptr)
      ptr += 1
      guard errFlag == 0 else {
        return
      }
      completionHandler(.success(()))
    }
  }

  @available(macOS 10.15, iOS 13, *)
  func updateWidgets(_ tag: [UInt32], _ widgets: [Widget], _ args: NanoPackMessage?) async
    -> Result<Void, NPRPCError>
  {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 14)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(14))
    data.append(string: "update_widgets")
    data.append(size: tag.count)
    for i in tag {
      data.append(int: i)
    }
    data.append(size: widgets.count)
    var widgetsByteSize: Size = 4
    for i in widgets {
      let iByteSize = i.write(to: &data, offset: data.count)
      widgetsByteSize += iByteSize
    }
    if let args {
      data.append(int: UInt8(1))
      let argsByteSize = args.write(to: &data, offset: data.count)
    } else {
      data.append(int: UInt8(0))
    }

    return await withCheckedContinuation { continuation in
      sendRequestData(msgID, data) { data, offset in
        var ptr = offset
        let errFlag: UInt8 = data.read(at: ptr)
        ptr += 1
        guard errFlag == 0 else {
          continuation.resume(returning: .failure(.malformedResponse))
          return
        }
        continuation.resume(returning: .success(()))
      }
    }
  }
}
