// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import Foundation
import NanoPack

protocol PortableLayerServiceDelegate {
  func invokeVoidCallback(_ handle: UInt32, _ args: NanoPackMessage)
  func invokeCallback(_ handle: UInt32, _ args: NanoPackMessage) -> NanoPackMessage
}

class PortableLayerServiceServer: NPRPCServer {
  private let delegate: PortableLayerServiceDelegate

  init(channel: NPRPCServerChannel, delegate: PortableLayerServiceDelegate) {
    self.delegate = delegate
    super.init(channel: channel)
    registerCalls()
  }

  private func registerCalls() {
    on("invoke_void_callback") { data, offset, msgID in
      var ptr = offset
      let handle: UInt32 = data.read(at: ptr)
      ptr += 4
      var argsByteSize = 0
      guard let args = makeNanoPackMessage(from: data[ptr...], bytesRead: &argsByteSize) else {
        return nil
      }
      ptr += argsByteSize

      self.delegate.invokeVoidCallback(handle, args)
      var data = Data(capacity: 6)
      data.append(int: NPRPCMessageType.response.rawValue)
      data.append(int: msgID)
      data.append(int: UInt8(0))

      return data
    }
    on("invoke_callback") { data, offset, msgID in
      var ptr = offset
      let handle: UInt32 = data.read(at: ptr)
      ptr += 4
      var argsByteSize = 0
      guard let args = makeNanoPackMessage(from: data[ptr...], bytesRead: &argsByteSize) else {
        return nil
      }
      ptr += argsByteSize

      let result = self.delegate.invokeCallback(handle, args)
      var data = Data(capacity: 6)
      data.append(int: NPRPCMessageType.response.rawValue)
      data.append(int: msgID)
      data.append(int: UInt8(0))
      let resultByteSize = result.write(to: &data, offset: data.count)
      return data
    }
  }
}

class PortableLayerServiceClient: NPRPCClient {
  override init(channel: NPRPCClientChannel) {
    super.init(channel: channel)
  }

  func invokeVoidCallback(
    _ handle: UInt32, _ args: NanoPackMessage,
    completionHandler: @escaping (Result<Void, NPRPCError>) -> Void
  ) {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 20)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(20))
    data.append(string: "invoke_void_callback")
    data.append(int: handle)
    let argsByteSize = args.write(to: &data, offset: data.count)

    sendRequestData(msgID, data) { data, offset in
      var ptr = offset
      let errFlag: UInt8 = data.read(at: ptr)
      ptr += 1
      guard errFlag == 0 else {
        return
      }
      completionHandler(.success(()))
    }
  }

  @available(macOS 10.15, iOS 13, *)
  func invokeVoidCallback(_ handle: UInt32, _ args: NanoPackMessage) async -> Result<
    Void, NPRPCError
  > {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 20)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(20))
    data.append(string: "invoke_void_callback")
    data.append(int: handle)
    let argsByteSize = args.write(to: &data, offset: data.count)

    return await withCheckedContinuation { continuation in
      sendRequestData(msgID, data) { data, offset in
        var ptr = offset
        let errFlag: UInt8 = data.read(at: ptr)
        ptr += 1
        guard errFlag == 0 else {
          continuation.resume(returning: .failure(.malformedResponse))
          return
        }
        continuation.resume(returning: .success(()))
      }
    }
  }

  func invokeCallback(
    _ handle: UInt32, _ args: NanoPackMessage,
    completionHandler: @escaping (Result<NanoPackMessage, NPRPCError>) -> Void
  ) {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 15)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(15))
    data.append(string: "invoke_callback")
    data.append(int: handle)
    let argsByteSize = args.write(to: &data, offset: data.count)

    sendRequestData(msgID, data) { data, offset in
      var ptr = offset
      let errFlag: UInt8 = data.read(at: ptr)
      ptr += 1
      guard errFlag == 0 else {
        return
      }
      var resultByteSize = 0
      guard let result = makeNanoPackMessage(from: data[ptr...], bytesRead: &resultByteSize) else {
        return completionHandler(.failure(.malformedResponse))
      }
      ptr += resultByteSize
      completionHandler(.success(result))
    }
  }

  @available(macOS 10.15, iOS 13, *)
  func invokeCallback(_ handle: UInt32, _ args: NanoPackMessage) async -> Result<
    NanoPackMessage, NPRPCError
  > {
    let msgID = newMessageID()
    var data = Data(capacity: 9 + 15)
    data.append(int: NPRPCMessageType.request.rawValue)
    data.append(int: msgID)
    data.append(int: UInt32(15))
    data.append(string: "invoke_callback")
    data.append(int: handle)
    let argsByteSize = args.write(to: &data, offset: data.count)

    return await withCheckedContinuation { continuation in
      sendRequestData(msgID, data) { data, offset in
        var ptr = offset
        let errFlag: UInt8 = data.read(at: ptr)
        ptr += 1
        guard errFlag == 0 else {
          continuation.resume(returning: .failure(.malformedResponse))
          return
        }
        var resultByteSize = 0
        guard let result = makeNanoPackMessage(from: data[ptr...], bytesRead: &resultByteSize)
        else {
          return continuation.resume(returning: .failure(.malformedResponse))
        }
        ptr += resultByteSize
        continuation.resume(returning: .success(result))
      }
    }
  }
}
